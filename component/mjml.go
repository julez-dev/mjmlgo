package component

import (
	"errors"
	"fmt"
	"io"
	"slices"
	"strings"

	"github.com/julez-dev/mjmlgo/node"
)

var ErrMJMLBadlyFormatted = errors.New("MJML badly formatted")

type MJML struct{}

func (m MJML) Name() string {
	return "mjml"
}

func (m MJML) AllowedAttributes() map[string]validateAttributeFunc {
	return map[string]validateAttributeFunc{
		"owa":  validateEnum([]string{"desktop"}),
		"lang": validateType("string"),
		"dir":  validateEnum([]string{"ltr", "rtl"}),
	}
}

func (m MJML) DefaultAttributes(_ *RenderContext) map[string]string {
	return map[string]string{
		"dir": "ltr",
	}
}

func (m MJML) Render(ctx *RenderContext, w io.Writer, n *node.Node) error {
	if len(n.Children) < 1 {
		return fmt.Errorf("%w: no children in <mjml> tag", ErrMJMLBadlyFormatted)
	}

	hasBody := slices.ContainsFunc(n.Children, func(node *node.Node) bool {
		return node.Type == BodyTagName
	})

	if !hasBody {
		return fmt.Errorf("%w: no <mj-body> in <mjml> tag", ErrMJMLBadlyFormatted)
	}

	if err := templates.ExecuteTemplate(w, "html-start-tag.tmpl", map[string]string{
		"lang": n.GetAttributeValueDefault("lang"),
		"dir":  n.GetAttributeValueDefault("dir"),
	}); err != nil {
		return err
	}

	ctx.Direction = n.GetAttributeValueDefault("dir")

	var headNode *node.Node

	var headTextBuilder strings.Builder
	var bodyTextBuilder strings.Builder
	var resultTextBuilder strings.Builder

	for _, child := range n.Children {
		switch child.Type {
		case HeadTagName:
			m.preparseHeadMetaValues(ctx, child)
			headNode = child
		case BodyTagName:
			m.setAttributeDefaults(ctx, child)
			body := MJMLBody{}
			if err := InitComponent(ctx, body, child); err != nil {
				return err
			}
			if err := body.Render(ctx, &bodyTextBuilder, child); err != nil {
				return err
			}
		}
	}

	// render head as last element, because there a custom MJML styles generated by rendering other components
	var head MJMLHead
	if err := head.Render(ctx, &headTextBuilder, headNode); err != nil {
		return fmt.Errorf("error rendering <mj-head>: %w", err)
	}

	resultTextBuilder.Grow(len(headTextBuilder.String()) + len(bodyTextBuilder.String()))
	_, _ = resultTextBuilder.WriteString(headTextBuilder.String())
	_, _ = resultTextBuilder.WriteString(bodyTextBuilder.String())

	_, _ = io.WriteString(w, resultTextBuilder.String())
	_, _ = io.WriteString(w, "</html>")

	return nil
}

func (m MJML) setAttributeDefaults(ctx *RenderContext, n *node.Node) {
	if strings.HasPrefix(n.Type, "mj-") {
		if n.Type == "mj-text" {
			for _, attr := range ctx.GlobalTextAttributes {
				if _, has := n.GetAttributeValue(attr.Name.Local); !has {
					n.SetAttribute(attr.Name.Local, attr.Value)
				}
			}
		}

		for _, attr := range ctx.GlobalAllAttributes {
			if _, has := n.GetAttributeValue(attr.Name.Local); !has {
				n.SetAttribute(attr.Name.Local, attr.Value)
			}
		}

		for _, child := range n.Children {
			m.setAttributeDefaults(ctx, child)
		}
	}
}

func (m MJML) preparseHeadMetaValues(ctx *RenderContext, n *node.Node) {
	for _, child := range n.Children {
		switch child.Type {
		case AttributesTagName:
			for _, nestedChild := range child.Children {
				switch nestedChild.Type {
				case TextTagName:
					ctx.GlobalTextAttributes = append(ctx.GlobalTextAttributes, nestedChild.Attributes...)
				case AllTagName:
					ctx.GlobalAllAttributes = append(ctx.GlobalAllAttributes, nestedChild.Attributes...)
				}
			}
		case BreakpointTagName:
			if p, found := child.GetAttributeValue("width"); found {
				ctx.Breakpoint = p
			}
		case PreviewTagName:
			ctx.PreviewText = child.Content
		}
	}
}
